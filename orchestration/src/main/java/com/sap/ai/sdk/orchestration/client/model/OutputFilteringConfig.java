/*
 * Orchestration
 * Orchestration is an inference service which provides common additional capabilities for business AI scenarios, such as content filtering and data masking. At the core of the service is the LLM module which allows for an easy, harmonized access to the language models of gen AI hub. The service is designed to be modular and extensible, allowing for the addition of new modules in the future. Each module can be configured independently and at runtime, allowing for a high degree of flexibility in the orchestration of AI services.
 *
 * The version of the OpenAPI document: 0.29.3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.sap.ai.sdk.orchestration.client.model;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/** OutputFilteringConfig */
@JsonPropertyOrder({
  OutputFilteringConfig.JSON_PROPERTY_FILTERS,
  OutputFilteringConfig.JSON_PROPERTY_STREAM_OPTIONS
})
@com.google.common.annotations.Beta
@javax.annotation.Generated(
    value = "org.openapitools.codegen.languages.JavaClientCodegen",
    comments = "Generator version: 7.9.0")
public class OutputFilteringConfig {
  public static final String JSON_PROPERTY_FILTERS = "filters";
  private List<FilterConfig> filters = new ArrayList<>();

  public static final String JSON_PROPERTY_STREAM_OPTIONS = "stream_options";
  private FilteringStreamOptions streamOptions;

  public OutputFilteringConfig() {}

  public OutputFilteringConfig filters(List<FilterConfig> filters) {

    this.filters = filters;
    return this;
  }

  public OutputFilteringConfig addFiltersItem(FilterConfig filtersItem) {
    if (this.filters == null) {
      this.filters = new ArrayList<>();
    }
    this.filters.add(filtersItem);
    return this;
  }

  /**
   * Configuration for content filtering services that should be used for the given filtering step
   * (input filtering or output filtering).
   *
   * @return filters
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_FILTERS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public List<FilterConfig> getFilters() {
    return filters;
  }

  @JsonProperty(JSON_PROPERTY_FILTERS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setFilters(List<FilterConfig> filters) {
    this.filters = filters;
  }

  public OutputFilteringConfig streamOptions(FilteringStreamOptions streamOptions) {

    this.streamOptions = streamOptions;
    return this;
  }

  /**
   * Get streamOptions
   *
   * @return streamOptions
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_STREAM_OPTIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public FilteringStreamOptions getStreamOptions() {
    return streamOptions;
  }

  @JsonProperty(JSON_PROPERTY_STREAM_OPTIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStreamOptions(FilteringStreamOptions streamOptions) {
    this.streamOptions = streamOptions;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    OutputFilteringConfig outputFilteringConfig = (OutputFilteringConfig) o;
    return Objects.equals(this.filters, outputFilteringConfig.filters)
        && Objects.equals(this.streamOptions, outputFilteringConfig.streamOptions);
  }

  @Override
  public int hashCode() {
    return Objects.hash(filters, streamOptions);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class OutputFilteringConfig {\n");
    sb.append("    filters: ").append(toIndentedString(filters)).append("\n");
    sb.append("    streamOptions: ").append(toIndentedString(streamOptions)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  public static class Builder {

    private OutputFilteringConfig instance;

    public Builder() {
      this(new OutputFilteringConfig());
    }

    protected Builder(OutputFilteringConfig instance) {
      this.instance = instance;
    }

    public OutputFilteringConfig.Builder filters(List<FilterConfig> filters) {
      this.instance.filters = filters;
      return this;
    }

    public OutputFilteringConfig.Builder streamOptions(FilteringStreamOptions streamOptions) {
      this.instance.streamOptions = streamOptions;
      return this;
    }

    /**
     * returns a built OutputFilteringConfig instance.
     *
     * <p>The builder is not reusable.
     */
    public OutputFilteringConfig build() {
      try {
        return this.instance;
      } finally {
        // ensure that this.instance is not reused
        this.instance = null;
      }
    }

    @Override
    public String toString() {
      return getClass() + "=(" + instance + ")";
    }
  }

  /** Create a builder with no initialized field. */
  public static OutputFilteringConfig.Builder builder() {
    return new OutputFilteringConfig.Builder();
  }

  /** Create a builder with a shallow copy of this instance. */
  public OutputFilteringConfig.Builder toBuilder() {
    return new OutputFilteringConfig.Builder()
        .filters(getFilters())
        .streamOptions(getStreamOptions());
  }
}
